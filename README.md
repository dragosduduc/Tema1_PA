----TEMA 1----<br><br>
--TASK 1--<br>
Am deschis fișierele de intrare și am extras cerințele din c.in într-un vector numit task, unde task[i] reprezintă task-ul i+1 și are valoarea 1 dacă i se dorește rezolvarea sau 0 dacă nu i se dorește rezolvarea. Am definit tipurile de date de care voi avea nevoie, respectiv Player și Team.
În funcția createInitialList are loc citirea elementelor din fișierul d.in și crearea listei pe care o vom utiliza. Într-o buclă care ciclează pentru fiecare echipă din test, se alocă spațiu de memorie echipei în sine și tuturor câmpurilor care au nevoie de alocare de memorie și se citesc informațiile despre echipă din d.in. La finalul buclei repetitive, noua echipă se adaugă în listă.

--TASK 2--<br>
Variablia maxPower va conține cea mai mare putere a lui 2 mai mică decât numărul de echipe citite la task-ul 1. Aceasta se calculează prin shift-area biților la stânga până când se obține cea mai mică putere a lui 2 mai mare decât numărul de echipe. După care se shift-ează la dreapta o poziție pentru a se obține valoarea căutată.
Așadar, acum știm câte echipe trebuie să rămână în listă, deci știm și câte trebuie să eliminăm. Echipele nu sunt sortate în vreun fel în listă, așa că de fiecare dată când vrem să ștergem o echipă trebuie să parcurgem toată lista și să căutăm echipa cu punctajul de echipă minim. Odată găsită, aceasta se elimină.
Task-ul 2 presupune doar modificări la lista creată la task-ul 1. Așadar, operațiile descrise mai sus se întâmplă doar dacă task[1] are valoarea 1 (similar se va întâmpla și pentru următoarele cerințe). Scrierea listei în fișierul de ieșire se produce după acest if, în afara acestuia. Cu alte cuvinte, dacă testul dorește doar rezolvarea task-ului 1, nu se va intra în if-ul aferent task-ului 2 și se va trece direct la scrierea listei. Dar dacă se dorește și rezolvarea task-ului 2, se va intra în if, se vor produce modificările la listă, iar după ieșirea din if se va afișa lista modificată.

--TASK 3--<br>
Pentru task-ul 3 am implementat toate funcțiile din curs specifice stivelor și cozilor, cu mențiunea că funcțiile pop și deQueue au fost modificate pentru a returna adresa elementului care a fost scos din structură. Pentru coadă am creat un nou tip de date, Match, care conține adresele către două echipe distincte. Cu alte cuvinte, un element al cozii va conține ambele echipe care dispută meciul.
În funcția moveMatchesFromListToQueue, echipele din lista creată la task-ul anterior se mută în coada pe care am definit-o mai sus. Adică, se alocă spațiu de memorie pentru o variabilă de tip Match, adresele celor două echipe din meci, care acum sunt goale, se leagă de primele două echipe din listă, head-ul listei se actualizează la a treia echipă din listă și meciul creat se pune în coada de meciuri (enQueue).
Cât timp au mai rămas cel puțin două echipe în turneu, adică cât timp se mai pot juca meciuri, acestea se joacă. Se scoate un element din coadă (deQueue), se compară punctajele echipelor în așa fel încât cea cu punctaj mai mare se introduce în stiva de câștigători (push) (stivele sunt de tip Team), iar cea cu punctaj mai mic în stiva de pierzători (dacă punctajele celor două echipe sunt egale, câștigă cea de-a doua echipă).
Fiecare iterație a buclei while rezolvă o rundă a turneului. Dacă ne aflăm la iterația în care sunt 16 echipe în turneu, adică fiecare stivă are câte 8 echipe, se copiază elementele stivei de câștigători într-o nouă listă pe care o vom folosi pentru implementarea task-ului 4.
Scopul împărțirii în stive de câștigători și pierzători este de a repopula coada de meciuri cu echipele care, în acest moment, se află în stiva de câștigători. Așadar, variabila care conține numărul de echipe din turneu se înjumătățește (pentru că rămân în turneu doar câștigătorii), se mută echipele câștigătoare din stivă în coadă prin funcția moveMatchesFromStackToQueue și se șterg elementele stivei de pierzători. Pe parcurs, s-au afișat meciurile din runda curentă și câștigătorii acestora.
În acest moment, coada este populată cu meciuri compuse din echipele câștigătoare, deci instrucțiunile prezentate până acum se pot relua într-o altă iterație a buclei repetitive pentru a se rezolva încă o rundă.
Bucla se termină în momentul în care a mai rămas o singură echipă în turneu, cea învingătoare. Aceasta nu se regăsește în coada de meciuri deoarece nu s-a putut forma un meci cu o singură echipă. În schimb, ea rămâne în stiva de câștigători, de unde trebuie să o scoatem manual și să o afișăm.

--TASK 4--<br>
Pentru crearea unui BST am pornit de la funcția insertInBST din curs, pe care am modificat-o în așa fel încât să creeze corect un BST și în cazul în care se introduc elemente cu același punctaj. Dacă elementul pe care vreau să îl introduc în BST are valoarea mai mică decât valoarea root-ului curent, voi apela recursiv funcția pentru subarborele din stânga. Analog pentru subarborele din dreapta. Dar dacă echipele au punctaje egale, criteriul de inserție devine numele echipelor. Dacă numele echipei pe care vreau să o introduc este primul în ordine alfabetică (strcmp(echipă_nouă, root) < 0), atunci introduc echipa în subarborele din stânga. Altfel, în subarborele din dreapta. Nu verific cazul în care strcmp == 0 deoarece ar însemna că echipele au același nume, ceea ce nu are sens.
În această funcție introduc treptat cele 8 echipe pe care le-am salvat la task-ul precedent. Echipele nu sunt sortate în vreun fel, motiv pentru care nu mai am nevoie de listă, deci o șterg. 
În final, afișez elementele în ordine descrescătoare. O parcurgere în inordine clasică (stânga-rădăcină-dreapta) ar afișa elementele în ordine crescătoare, deoarece "cel mai din stânga" element are cea mai mică valoare, iar "cel mai din dreapta" element are cea mai mare valoare. Așadar îmi definesc o funcție inorderReverse, care parcurge BST-ul în ordinea dreapta-rădăcină-stânga. Astfel, se începe cu cel mai mare element, deci BST-ul se parcurge în ordine descrescătoare.

--TASK 5--<br>
În AVL, echipele trebuie introduse în ordine descrescătoare a punctajelor (sau a numelor, dacă punctajele sunt egale). Așadar parcurg CRESCĂTOR elementele din BST și le copiez la începutul unei noi liste. Le introduc la început, adică ultima echipă -cea cu punctajul cel mai mare- va deveni prima echipă din listă. Deci noua listă conține echipele sortate descrescător.
Pentru introducerea efectivă a unui nod într-un AVL se pleacă de la introducerea unui nod intr-un BST, adică funcția de la task-ul anterior. Schimbarea constă în aflarea și interpretarea factorului de echilibru. Dacă după inserția unui nod arborele se dezechilibrează, se aplică rotația corespunzătoare. Am implementat cele patru rotații din curs, am stabilit condițiile de rotație în funcție de punctajele echipelor și am introdus condițiile complementare în situația în care punctajele sunt egale, situație în care criteriul de rotație devine numele echipelor.
În acest moment, funcția de inserare în AVL este finalizată. Am aplicat-o pentru fiecare echipă din lista pe care tocmai am definit-o și am afișat echipele de pe nivelul 2 (root-ul arborelui se află pe nivelul 0). În final, am eliberat spațiile de memorie alocate BST-ului și AVL-ului.
